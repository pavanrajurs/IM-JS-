<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // ----------------------------------------
    // ğŸ§  Lexical Scope - The Setup
    // ----------------------------------------

    function outer() {
      const outerVar = "I'm outside!";

      function inner() {
        console.log(outerVar); // âœ… Can access outerVar
      }

      inner(); // call inner
    }

    outer();
    // Output: I'm outside!


    // ----------------------------------------
    // ğŸ’¡ Lexical Scope = "Where was the function defined"
    // ----------------------------------------

    const globalVar = "Global";

    function outerFunc() {
      const outerVar = "Outer";

      function innerFunc() {
        console.log(globalVar); // âœ… Lexical scope says: Check outer â†’ then global
        console.log(outerVar);  // âœ… Found in outerFunc
      }

      return innerFunc;
    }

    const callInner = outerFunc();
    callInner(); // Output: Global, Outer



    // ----------------------------------------
    // ğŸ”’ Closures - Keeping Data Alive
    // ----------------------------------------

    function counter() {
      let count = 0;

      return function () {
        count++;
        console.log("Count:", count);
      };
    }

    const inc = counter();
    inc(); // Count: 1
    inc(); // Count: 2
    inc(); // Count: 3

    // âœ… Even though 'counter' is done executing,
    // the inner function still remembers 'count' ğŸ‘€


    // ----------------------------------------
    // âš ï¸ Common Closure Trap (Inside Loops)
    // ----------------------------------------

    console.log("\nLoop + Closure ğŸ”¥");

    for (var i = 0; i < 3; i++) {
      setTimeout(() => {
        console.log("var i:", i); // âŒ Always prints 3, 3, 3
      }, 100);
    }

    // âœ… Fix it with let (block scoped)
    for (let j = 0; j < 3; j++) {
      setTimeout(() => {
        console.log("let j:", j); // âœ… Prints 0, 1, 2
      }, 100);
    }


    // ----------------------------------------
    // âœ… Closure Use Case: Private Variables
    // ----------------------------------------

    function secretHolder(secret) {
      return {
        getSecret: function () {
          return secret;
        },
        setSecret: function (newSecret) {
          secret = newSecret;
        }
      };
    }

    const obj = secretHolder("ğŸ§  original");
    console.log(obj.getSecret()); // ğŸ§  original
    obj.setSecret("ğŸ’¥ updated");
    console.log(obj.getSecret()); // ğŸ’¥ updated


    // ----------------------------------------
    // ğŸ§¨ Closure + Garbage Collection (Tricky Corner Case)
    // ----------------------------------------

    function leakyFunction() {
      const hugeData = new Array(1000000).fill("ğŸ“¦");

      return function () {
        console.log("Still holding hugeData...");
      };
    }

    const leaker = leakyFunction();
    // leaker = null; // ğŸ‘ˆ Uncomment to release memory

    // Even if leakyFunction is done, hugeData stays in memory
    // because closure keeps it alive âš ï¸


    // ----------------------------------------
    // ğŸ§  Summary for Interview Drop
    // ----------------------------------------

    // Lexical Scope = Where the function is defined (not called)
    // Closure = Function + Its Lexical Scope stays alive
    // Closures let you:
    // - Preserve state
    // - Create private variables
    // - Avoid polluting global scope
    // - Screw up memory if youâ€™re careless ğŸ˜…







  </script>

</body>

</html>