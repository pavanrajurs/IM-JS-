<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /**************************************
  PROMISES, ASYNC/AWAIT - FULL WALKTHROUGH
  Author: Pawan (with ChatGPT support)
**************************************/

    // Example 1Ô∏è‚É£ - Basic Promise with resolve and reject
    const basicPromise = new Promise((resolve, reject) => {
      const isSuccessful = true;

      if (isSuccessful) {
        resolve("‚úÖ Operation successful.");
      } else {
        reject("‚ùå Operation failed.");
      }
    });

    // Consuming using then/catch
    basicPromise
      .then((result) => {
        console.log("Then/Catch -> Resolved:", result);
      })
      .catch((error) => {
        console.log("Then/Catch -> Rejected:", error);
      });


    // Example 2Ô∏è‚É£ - Async/Await version of same promise
    async function consumeBasicPromise() {
      try {
        const result = await basicPromise;
        console.log("Async/Await -> Resolved:", result);
      } catch (error) {
        console.log("Async/Await -> Rejected:", error);
      }
    }
    consumeBasicPromise();


    // Example 3Ô∏è‚É£ - Simulating real-world API call
    function mockApiCall(success = true) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (success) {
            resolve("üì¶ API responded with data.");
          } else {
            reject("üö´ API failed to respond.");
          }
        }, 1000);
      });
    }

    // Using async/await with simulated API
    async function fetchApiData() {
      try {
        const response = await mockApiCall(true); // try false to test rejection
        console.log("API Success:", response);
      } catch (error) {
        console.log("API Error:", error);
      }
    }
    fetchApiData();


    // Example 4Ô∏è‚É£ - Another mock to simulate server status
    function checkServerStatus() {
      return new Promise((resolve, reject) => {
        const isOnline = Math.random() > 0.5;
        setTimeout(() => {
          if (isOnline) {
            resolve("üü¢ Server is online.");
          } else {
            reject("üî¥ Server is down.");
          }
        }, 500);
      });
    }

    async function monitorServer() {
      try {
        const status = await checkServerStatus();
        console.log("Server Check:", status);
      } catch (error) {
        console.error("Server Error:", error);
      }
    }
    monitorServer();


    // Example 5Ô∏è‚É£ - Real-world analogy: Ordering food
    function orderFood(foodAvailable) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          if (foodAvailable) {
            resolve("üçï Your order has been delivered.");
          } else {
            reject("üò¢ Sorry, food is unavailable.");
          }
        }, 800);
      });
    }

    async function handleFoodOrder() {
      try {
        const deliveryStatus = await orderFood(true); // set to false for rejection
        console.log("Food Order:", deliveryStatus);
      } catch (error) {
        console.log("Food Order Failed:", error);
      }
    }
    handleFoodOrder();


    /**************************************
      üí° Summary:
      - Promises are used for async tasks
      - .then/.catch is old-school, still works
      - async/await is modern and cleaner
      - Always wrap await in try/catch
      - You can simulate real APIs using setTimeout
      - Everything async returns a Promise!
    **************************************/


  </script>
</body>

</html>